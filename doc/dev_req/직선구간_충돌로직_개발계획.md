요청한 대로 **직선 구간 충돌 검사 로직 개발 계획**을 정리한 MD 파일 내용이다.
다른 Agent에게 이 문서를 넘겨주면, 네가 의도한 기하학적 구조와 최적화 로직을 정확히 구현할 수 있을 것이다.

-----

# 직선 구간 충돌 검사 로직 개발 계획 (Linear Collision Logic Plan)

## 1\. 개요 (Overview)

본 문서는 VOS(Vehicle Operation System)의 충돌 검사 엔진 중, **직선(Linear) Edge**에서의 차량 충돌 방지 로직을 정의한다.
기존의 단순 `toNode` 거리 기반 검사 방식의 한계를 극복하고, **곡선(Curve) Edge의 Tail(직선 연장 구간) 합류 특성**을 반영하여 물리적 충돌을 방지하는 것을 목표로 한다.

## 2\. 문제 정의 및 기하학적 전제

### 2.1. 곡선 Edge의 구조적 특성

  * 곡선 Edge는 단순한 호(Arc)가 아니다.
  * 구조: `fromNode` $\rightarrow$ `nodes[1]` (직선 진입) $\rightarrow$ **[곡선 구간]** $\rightarrow$ `nodes[-2]` (곡선 종료) $\rightarrow$ `toNode` (직선 진출)
  * **Merge Point:** 물리적인 합류는 `toNode`가 아닌, 곡선 구간이 끝나는 **`nodes[-2]`** 지점부터 시작된다.
  * 따라서, 직선 Edge와 곡선 Edge가 합류할 때, **`nodes[-2]` \~ `toNode` 구간(Tail)은 공간적으로 중첩**된다.

### 2.2. 기존 로직의 문제점

  * 단순히 직선 Edge의 끝(`toNode`)만 기준으로 검사할 경우, `nodes[-2]`에서 이미 합류해 들어오는 곡선 차량을 감지하지 못해 측면 충돌 발생.

## 3\. 해결 전략: 구간 분할 (Zone Partitioning)

직선 Edge를 두 개의 구간으로 논리적으로 분할하여 연산 비용을 최적화한다.

1.  **Safe Zone (안전 구간):**
      * 합류 위험이 없는 구간.
      * 로직: 오직 \*\*자기 앞차(Predecessor)\*\*와의 거리만 계산 (O(1)).
2.  **Danger Zone (위험/합류 구간):**
      * 곡선의 Tail과 겹치는 구간.
      * 범위: `LinearEdge.Length` - `CurveTailLength` - `SafetyMargin`.
      * 로직: **자기 앞차** 검사 + **합류하는 곡선 차량**과의 유클리드 거리(Sensor) 검사.

## 4\. 데이터 요구사항 (Data Requirements)

### 4.1. Map Data (Pre-computation)

맵 로딩 시점에 다음 데이터가 직선 Edge 속성으로 준비되어야 한다.

  * `isMergeTarget`: 해당 직선이 합류 지점인지 여부.
  * `mergingEdgeIdx`: 합류해 들어오는 상대 곡선 Edge의 Index.
  * `mergeStartOffset`: 직선 Edge 상에서 위험 구간이 시작되는 거리 값.
      * *Formula:* `Edge.Length - Distance(Curve.nodes[-2], Curve.toNode) - (VehicleLen * 2)`

### 4.2. Runtime Data

  * `VehicleArray`: 전체 차량의 위치 데이터 (Float32Array).
  * `EdgeVehicleQueue`: 각 Edge별 차량 존재 여부 및 Count (Zero-allocation).

## 5\. 상세 알고리즘 (Algorithm Details)

### 5.1. Main Function: `verifyLinearCollision`

모든 차량에 대해 반복문을 돌되, 차량의 현재 위치(`currentPos`)에 따라 검사 로직을 분기한다.

```typescript
// Pseudo-code Structure
function verifyLinearCollision(edgeIdx, edge, vehicleData) {
    if (!isMergeTarget(edge)) {
        // Case A: 합류 없음 (단순 직선)
        runStandardCheck(); 
    } else {
        // Case B: 합류 있음 (Merge Logic)
        runMergeCheck(edge.mergingEdgeIdx, edge.mergeStartOffset);
    }
}
```

### 5.2. Case A: 단순 직선 (No Merge)

  * **Lead Vehicle:** 다음 Edge로의 진입 가능 여부만 체크 (`toNode` 점유 상태).
  * **Following Vehicles:** `index - 1` 차량과의 간격(`gap`)만 체크.

### 5.3. Case B: 합류 직선 (Merge Scenario)

차량 위치 `pos`와 `mergeStartOffset`을 비교한다.

#### **Zone 1: Safe Zone (`pos < mergeStartOffset`)**

  * **Action:** Case A와 동일. 내 앞차와의 간격만 유지.
  * **Optimization:** 다른 Edge의 데이터를 조회하거나 유클리드 거리를 계산하지 않음.

#### **Zone 2: Danger Zone (`pos >= mergeStartOffset`)**

  * **Action 1 (Self-Line Check):** 내 앞차와의 간격 유지 (기본).
  * **Action 2 (Cross-Line Check):**
    1.  합류하는 곡선 Edge(`mergingEdgeIdx`)의 차량 리스트 조회.
    2.  곡선 차량 중 **Tail 구간**(`nodes[-2]` 이후)에 진입한 차량만 필터링.
    3.  내 차량과 대상 차량 간의 **유클리드 거리 제곱($d^2$)** 계산.
    4.  `d^2 < SensorRange^2` 인 경우 충돌 위험 간주.
  * **Collision Handling:**
      * 우선순위 결정은 `LockMgr`가 수행하나, 물리적 겹침 발생 시 **즉시 정지(Emergency Stop)**.

## 6\. 데드락(Deadlock) 방지 대책

  * 본 로직은 물리적 충돌을 막기 위한 **Fail-Safe** 장치임.
  * 교차로 통행 우선순위(누가 먼저 갈 것인가)는 **`LockMgr`** 시스템이 사전에 제어해야 함.
  * 따라서, `LockMgr`가 정상 작동한다면 Danger Zone에서의 유클리드 거리 검사는 `false`가 나와야 정상임.

## 7\. 구현 시 주의사항

1.  **좌표 변환:** `nodes[-2]`의 좌표가 직선 벡터 위에 정확히 있지 않을 수 있음을 감안하여, 벡터 투영(Projection)을 통해 `offset`을 계산할 것.
2.  **성능 최적화:** `Math.sqrt` 사용을 금지하고, 거리 비교는 항상 `Squared Distance`로 수행할 것.
3.  **상수 관리:** `VehicleLength`, `SensorRange` 등은 하드코딩하지 말고 설정 파일로 관리할 것.

-----

**작성자:** Gemini (Thought Partner)
**작성일:** 2025-12-11

-----

### 다음 단계 (Next Step)

이 문서를 바탕으로 구현 Agent에게 작업을 지시하면 된다.
혹시 **`nodes[-2]` 투영(Projection) 로직**이나 **`LockMgr`와의 연동 인터페이스** 정의가 추가로 필요하면 말해달라.